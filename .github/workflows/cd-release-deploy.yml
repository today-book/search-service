name: CD (release) - Deploy to Prod

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      version:
        description: "Deploy version tag (e.g. 1.2.3)"
        required: true
      sha:
        description: "Commit SHA to deploy (optional if version tag exists)"
        required: false
      update_latest:
        description: "Also move :latest to this version?"
        required: false
        type: choice
        options: ["true", "false"]
        default: "true"

permissions:
  contents: read
  packages: write
  id-token: write

concurrency:
  group: deploy-prod-${{ github.ref }}
  cancel-in-progress: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  APP_NAME: search-service
  AWS_REGION_PROD: ap-northeast-2
  # SSM Tags
  PROD_ENV_TAG_KEY: "tag:Env"
  PROD_ENV_TAG_VALUE: "prod"
  PROD1_NODE_TAG_KEY: "tag:Node"
  PROD1_NODE_TAG_VALUE: "api-bundle-1"
  PROD2_NODE_TAG_KEY: "tag:Node"
  PROD2_NODE_TAG_VALUE: "api-bundle-2"

jobs:
  # 1) Ïù¥ÎØ∏ÏßÄ Ï§ÄÎπÑ Î∞è ÌÉúÍ∑∏ ÏäπÍ≤©
  prepare-image:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.out.outputs.version }}
      update_latest: ${{ steps.out.outputs.update_latest }}
    steps:
      - name: Resolve VERSION & UPDATE_LATEST
        shell: bash
        run: |
          if [[ "${{ github.event_name }}" == "release" ]]; then
            echo "VERSION=${GITHUB_REF_NAME}" >> "$GITHUB_ENV"
            echo "UPDATE_LATEST=true" >> "$GITHUB_ENV"
          else
            echo "VERSION=${{ inputs.version }}" >> "$GITHUB_ENV"
            echo "UPDATE_LATEST=${{ inputs.update_latest || 'true' }}" >> "$GITHUB_ENV"
          fi

      - name: Resolve SHA
        shell: bash
        run: |
          if [[ "${{ github.event_name }}" == "release" ]]; then
            echo "SHA=${{ github.sha }}" >> "$GITHUB_ENV"
          else
            echo "SHA=${{ inputs.sha }}" >> "$GITHUB_ENV"
          fi

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Ensure/Promote Image
        uses: docker/setup-buildx-action@v3
      - shell: bash
        run: |
          TARGET="${REGISTRY}/${IMAGE_NAME}:${VERSION}"
          if docker buildx imagetools inspect "$TARGET" >/dev/null 2>&1; then
            echo "‚úÖ Image $TARGET already exists."
          else
            SRC="${REGISTRY}/${IMAGE_NAME}:main-${SHA}"
            echo "üöÄ Promoting $SRC to $TARGET"
            docker buildx imagetools create "$SRC" --tag "$TARGET"
          fi

      - id: out
        run: |
          echo "version=${VERSION}" >> "$GITHUB_OUTPUT"
          echo "update_latest=${UPDATE_LATEST}" >> "$GITHUB_OUTPUT"

  # 2) PROD-1 Î∞∞Ìè¨
  deploy-prod-1:
    needs: prepare-image
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION_PROD }}
          role-to-assume: ${{ secrets.AWS_DEPLOY_PROD_ROLE_ARN }}

      - name: Deploy to prod-1
        shell: bash
        env:
          VERSION: ${{ needs.prepare-image.outputs.version }}
          GHCR_USER: ${{ secrets.GHCR_USER }}
          GHCR_PAT: ${{ secrets.GHCR_PAT }}
        run: |
          set -euo pipefail

          # 'EOF'Î•º ÏÇ¨Ïö©ÌïòÏó¨ GitHub Actions Îã®Í≥ÑÏóêÏÑú Î≥ÄÏàòÍ∞Ä ÎØ∏Î¶¨ ÏπòÌôòÎêòÎäî Í≤ÉÏùÑ Î∞©ÏßÄ
          RAW_SCRIPT=$(cat <<'EOF'
          #!/bin/bash
          set -euo pipefail
          cd /srv/todaybook/search-service
          echo "$GHCR_PAT" | sudo docker login ghcr.io -u "$GHCR_USER" --password-stdin
          chmod +x deploy.sh
          ./deploy.sh
          EOF
          )
          
          # envsubstÎ•º ÏÇ¨Ïö©ÌïòÏó¨ GitHub ActionÏùò env Í∞íÏùÑ Ïä§ÌÅ¨Î¶ΩÌä∏Ïóê Ï£ºÏûÖ
          export GHCR_USER GHCR_PAT
          export SCRIPT=$(echo "$RAW_SCRIPT" | envsubst '$GHCR_USER $GHCR_PAT')

          PARAMS=$(python3 -c "import json, os; print(json.dumps({'commands': os.environ['SCRIPT'].splitlines()}))")

          CMD_ID=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "Key=${PROD_ENV_TAG_KEY},Values=${PROD_ENV_TAG_VALUE}" "Key=${PROD1_NODE_TAG_KEY},Values=${PROD1_NODE_TAG_VALUE}" \
            --parameters "$PARAMS" \
            --query "Command.CommandId" --output text)

          echo "Waiting for SSM Command: $CMD_ID"
          while true; do
            STATUS=$(aws ssm list-command-invocations --command-id "$CMD_ID" --details --query "CommandInvocations[0].Status" --output text 2>/dev/null || echo "Pending")
            echo "Current status: $STATUS"
            if [[ "$STATUS" == "Success" ]]; then break;
            elif [[ "$STATUS" =~ ^(Failed|Cancelled|TimedOut)$ ]]; then
              aws ssm list-command-invocations --command-id "$CMD_ID" --details
              exit 1
            fi
            sleep 5
          done

  # 3) PROD-2 Î∞∞Ìè¨
  deploy-prod-2:
    needs: [prepare-image, deploy-prod-1]
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION_PROD }}
          role-to-assume: ${{ secrets.AWS_DEPLOY_PROD_ROLE_ARN }}

      - name: Deploy to prod-2
        shell: bash
        env:
          VERSION: ${{ needs.prepare-image.outputs.version }}
          GHCR_USER: ${{ secrets.GHCR_USER }}
          GHCR_PAT: ${{ secrets.GHCR_PAT }}
        run: |
          set -euo pipefail

          RAW_SCRIPT=$(cat <<'EOF'
          #!/bin/bash
          set -euo pipefail
          cd /srv/todaybook/search-service
          echo "$GHCR_PAT" | sudo docker login ghcr.io -u "$GHCR_USER" --password-stdin
          chmod +x deploy.sh
          ./deploy.sh
          EOF
          )
          
          export GHCR_USER GHCR_PAT
          export SCRIPT=$(echo "$RAW_SCRIPT" | envsubst '$GHCR_USER $GHCR_PAT')

          PARAMS=$(python3 -c "import json, os; print(json.dumps({'commands': os.environ['SCRIPT'].splitlines()}))")

          CMD_ID=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "Key=${PROD_ENV_TAG_KEY},Values=${PROD_ENV_TAG_VALUE}" "Key=${PROD2_NODE_TAG_KEY},Values=${PROD2_NODE_TAG_VALUE}" \
            --parameters "$PARAMS" \
            --query "Command.CommandId" --output text)

          echo "Waiting for SSM Command: $CMD_ID"
          while true; do
            STATUS=$(aws ssm list-command-invocations --command-id "$CMD_ID" --details --query "CommandInvocations[0].Status" --output text 2>/dev/null || echo "Pending")
            echo "Current status: $STATUS"
            if [[ "$STATUS" == "Success" ]]; then break;
            elif [[ "$STATUS" =~ ^(Failed|Cancelled|TimedOut)$ ]]; then
              aws ssm list-command-invocations --command-id "$CMD_ID" --details
              exit 1
            fi
            sleep 5
          done

  # 4) latest ÌÉúÍ∑∏ Í∞±Ïã†
  update-latest:
    needs: [prepare-image, deploy-prod-1, deploy-prod-2]
    if: ${{ needs.prepare-image.outputs.update_latest == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Tag Latest
        run: |
          VERSION="${{ needs.prepare-image.outputs.version }}"
          docker buildx imagetools create "${REGISTRY}/${IMAGE_NAME}:${VERSION}" --tag "${REGISTRY}/${IMAGE_NAME}:latest"